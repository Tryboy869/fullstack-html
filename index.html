<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulateur Tactique de Football 2D (Corrigé)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .pitch-bg {
            background-color: #2a9d8f;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .no-select {
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
        }
        .tab-active {
            background-color: #f7b731;
            color: #1a202c;
        }
        .tab-inactive {
            background-color: #4a5568;
        }
        .phase-active {
            background-color: #2c7a7b;
            border-color: #f7b731;
        }
        .phase-inactive {
            background-color: #2d3748;
        }
        /* Make scrollbars less obtrusive */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2d3748; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col no-select">

    <!-- Header -->
    <header class="bg-gray-800 p-3 shadow-lg flex flex-col sm:flex-row items-center justify-between gap-2">
        <h1 class="text-lg sm:text-xl font-bold text-gray-100 text-center sm:text-left">Simulateur Tactique 2D</h1>
        <div id="score-display" class="text-xl sm:text-2xl font-bold tracking-wider text-center">
            <span id="team-a-name-display" class="text-blue-400">Équipe A</span> 0 - 0 <span id="team-b-name-display" class="text-red-400">Équipe B</span>
        </div>
        <div class="text-xl font-mono" id="time-display">00:00</div>
    </header>

    <!-- Main Content: Flex column on mobile, flex row on large screens -->
    <div class="flex flex-1 flex-col lg:flex-row overflow-hidden">
        
        <!-- Tactical Configuration Panel -->
        <aside class="w-full lg:w-1/3 lg:max-w-md xl:max-w-lg bg-gray-800 p-4 overflow-y-auto flex flex-col space-y-4 lg:h-full">
            
            <!-- Match Controls -->
            <div class="bg-gray-700 p-4 rounded-lg shadow-md">
                <h2 class="text-lg font-semibold mb-3 border-b border-gray-600 pb-2">Contrôles du Match</h2>
                <div class="flex space-x-2">
                    <button id="start-match" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Lancer</button>
                    <button id="pause-match" class="flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-md transition duration-300" disabled>Pause</button>
                    <button id="reset-match" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Reset</button>
                </div>
                 <div class="mt-3">
                    <label for="sim-speed" class="block text-sm font-medium text-gray-300">Vitesse: <span id="sim-speed-value">1</span>x</label>
                    <input id="sim-speed" type="range" min="1" max="10" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <!-- Global Settings -->
            <div class="bg-gray-700 p-4 rounded-lg shadow-md">
                <h2 class="text-lg font-semibold mb-3 border-b border-gray-600 pb-2">Paramètres de Tir</h2>
                <div>
                    <label for="shot-distance" class="block text-sm font-medium text-gray-300">Distance de tir max: <span id="shot-distance-value">25</span>m</label>
                    <input id="shot-distance" type="range" min="5" max="35" value="25" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <!-- Team Configuration Tabs -->
            <div class="flex-1 bg-gray-700 p-4 rounded-lg shadow-md flex flex-col min-h-[400px] lg:min-h-0">
                <div class="flex rounded-md mb-4">
                    <button id="tab-team-a" class="tab-team flex-1 p-2 font-semibold rounded-l-md transition duration-300 tab-active">Équipe A</button>
                    <button id="tab-team-b" class="tab-team flex-1 p-2 font-semibold rounded-r-md transition duration-300 tab-inactive">Équipe B</button>
                </div>

                <div id="config-panel-team-a" class="team-config-panel flex-1 flex flex-col min-h-0">
                    <!-- Config content will be dynamically inserted here -->
                </div>
                 <div id="config-panel-team-b" class="team-config-panel hidden flex-1 flex flex-col min-h-0">
                    <!-- Config content will be dynamically inserted here -->
                </div>
            </div>

        </aside>

        <!-- Main Simulation Area -->
        <main class="flex-1 flex flex-col p-4 bg-gray-900 min-h-0">
            <div class="w-full h-full flex items-center justify-center relative flex-1">
                 <canvas id="football-pitch" class="bg-green-700 rounded-lg shadow-2xl pitch-bg border-2 border-gray-600"></canvas>
            </div>
            <!-- Event Log -->
            <div class="h-24 md:h-32 bg-gray-800 mt-4 rounded-lg p-2 overflow-y-auto">
                <h3 class="font-semibold text-gray-400">Log des Événements</h3>
                <div id="event-log" class="text-sm font-mono text-gray-300 whitespace-pre-wrap"></div>
            </div>
        </main>
    </div>

<script type="module">
// ===================================================================================
// ILN Niveau 1 - Unification dans un seul fichier
// ===================================================================================

// -----------------------------------------------------------------------------------
// Section 0: Setup & Initialisation
// -----------------------------------------------------------------------------------
const PITCH_WIDTH = 105; // meters
const PITCH_HEIGHT = 68; // meters
const GOAL_WIDTH = 7.32;

const canvas = document.getElementById('football-pitch');
const ctx = canvas.getContext('2d');

let scale;
let canvasWidth, canvasHeight;

function resizeCanvas() {
    const container = canvas.parentElement;
    const containerStyle = getComputedStyle(container);
    const availableWidth = container.clientWidth - parseFloat(containerStyle.paddingLeft) - parseFloat(containerStyle.paddingRight);
    const availableHeight = container.clientHeight - parseFloat(containerStyle.paddingTop) - parseFloat(containerStyle.paddingBottom);
    
    if (availableWidth <= 0 || availableHeight <= 0) return; // Guard clause

    const pitchRatio = PITCH_WIDTH / PITCH_HEIGHT;
    const containerRatio = availableWidth / availableHeight;
    
    if (containerRatio > pitchRatio) {
        canvasHeight = availableHeight;
        canvasWidth = canvasHeight * pitchRatio;
    } else {
        canvasWidth = availableWidth;
        canvasHeight = canvasWidth / pitchRatio;
    }
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    scale = canvasWidth / PITCH_WIDTH;
    
    if(renderer) {
        renderer.draw();
    }
}

// -----------------------------------------------------------------------------------
// Section 1: Classes de base (Vector, Player, Team, Ball, MatchEngine, Renderer, UIController)
// -----------------------------------------------------------------------------------

class Vector2D {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    add(v) { return new Vector2D(this.x + v.x, this.y + v.y); }
    subtract(v) { return new Vector2D(this.x - v.x, this.y - v.y); }
    multiply(s) { return new Vector2D(this.x * s, this.y * s); }
    magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { const mag = this.magnitude(); return mag > 0 ? this.multiply(1 / mag) : new Vector2D(); }
    distanceTo(v) { return this.subtract(v).magnitude(); }
}

class Player {
    constructor(id, team, number, color) {
        this.id = id;
        this.team = team;
        this.number = number;
        this.color = color;
        this.isGoalkeeper = (number === 1);
        
        this.position = new Vector2D();
        this.velocity = new Vector2D();
        
        this.stamina = 100;
        this.burst = 100;
        this.baseSkill = 70; // 0-100
        this.fatigueFactor = 1;

        this.tactics = {
            'with_ball': { position: new Vector2D(), instructions: [] },
            'without_ball': { position: new Vector2D(), instructions: [] }
        };
        this.targetPosition = new Vector2D();
    }

    update(deltaTime, intensity) {
        // Movement
        const direction = this.targetPosition.subtract(this.position);
        const distance = direction.magnitude();
        if (distance > 0.1) {
            this.velocity = direction.normalize().multiply(this.isGoalkeeper ? 3 : 5 * this.fatigueFactor);
            this.position = this.position.add(this.velocity.multiply(deltaTime));
        }

        // Energy
        this.updateEnergy(deltaTime, intensity);
    }
    
    updateEnergy(deltaTime, intensity) {
        const minuteFraction = deltaTime / 60;
        const staminaDrainRate = { 'low': 0.4, 'normal': 1.0, 'high': 2.5 };
        this.stamina -= (staminaDrainRate[intensity] || 1.0) * minuteFraction;
        this.stamina = Math.max(0, this.stamina);

        this.burst += 1.5 * minuteFraction;
        this.burst = Math.min(100, this.burst);
        
        this.fatigueFactor = 0.5 + (this.stamina / 100) * 0.5;
    }

    useBurst(amount) {
        if (this.burst >= amount) {
            this.burst -= amount;
            return true;
        }
        return false;
    }
}

class Team {
    constructor(id, name, color, side) {
        this.id = id;
        this.name = name;
        this.color = color;
        this.side = side; // 'left' or 'right'
        this.players = [];
        this.score = 0;
        this.hasBall = false;
        
        this.generalTactics = {
            offensiveStyle: 'possession',
            defensiveStyle: 'mid_block'
        };

        for (let i = 1; i <= 11; i++) {
            this.players.push(new Player(`${id}-${i}`, this, i, color));
        }
        this.setInitialPositions();
    }

    setInitialPositions(formation = '442') {
        const positions = {
            '442': [
                [0.05, 0.5], // GK
                [0.2, 0.2], [0.2, 0.4], [0.2, 0.6], [0.2, 0.8], // DEF
                [0.5, 0.2], [0.5, 0.4], [0.5, 0.6], [0.5, 0.8], // MID
                [0.8, 0.4], [0.8, 0.6] // FWD
            ]
        };
        
        const formationPos = positions[formation];
        this.players.forEach((player, i) => {
            let x = formationPos[i][0] * PITCH_WIDTH;
            let y = formationPos[i][1] * PITCH_HEIGHT;
            if(this.side === 'right') x = PITCH_WIDTH - x;

            const pos = new Vector2D(x, y);
            player.tactics.with_ball.position = new Vector2D(pos.x, pos.y);
            player.tactics.without_ball.position = new Vector2D(pos.x, pos.y);
            player.position = new Vector2D(pos.x, pos.y);
        });
    }

    update(deltaTime) {
        let intensity = 'normal';
        if (this.generalTactics.defensiveStyle === 'high_press' && !this.hasBall) {
            intensity = 'high';
        } else if(this.generalTactics.offensiveStyle === 'possession' && this.hasBall) {
            intensity = 'low';
        }

        this.players.forEach(p => {
            const currentPhase = this.hasBall ? 'with_ball' : 'without_ball';
            p.targetPosition = p.tactics[currentPhase].position;
            p.update(deltaTime, intensity);
        });
    }
}

class Ball {
    constructor() {
        this.position = new Vector2D(PITCH_WIDTH / 2, PITCH_HEIGHT / 2);
        this.velocity = new Vector2D();
        this.carrier = null;
        this.friction = 0.98;
    }

    update(deltaTime) {
        if (this.carrier) {
            this.position = this.carrier.position.add(new Vector2D(0.5, 0.5));
            this.velocity = new Vector2D();
        } else {
            this.position = this.position.add(this.velocity.multiply(deltaTime));
            this.velocity = this.velocity.multiply(this.friction);
        }
    }
}

class MatchEngine {
    constructor(teamA, teamB) {
        this.teamA = teamA;
        this.teamB = teamB;
        this.ball = new Ball();
        
        this.time = 0;
        this.isPaused = true;
        this.simulationSpeed = 1;
        this.eventCooldown = false;

        this.kickOff();
    }

    kickOff() {
        this.isPaused = true;
        this.ball.position = new Vector2D(PITCH_WIDTH / 2, PITCH_HEIGHT / 2);
        this.ball.velocity = new Vector2D();
        this.ball.carrier = null;
        this.teamA.hasBall = false;
        this.teamB.hasBall = false;
        
        setTimeout(() => {
             const startingTeam = Math.random() < 0.5 ? this.teamA : this.teamB;
             const startingPlayer = startingTeam.players.find(p => p.number === 10) || startingTeam.players[8];
             this.ball.carrier = startingPlayer;
             startingTeam.hasBall = true;
             
             if(document.getElementById('start-match').disabled) {
                this.isPaused = false;
             }
        }, 1500);
    }
    
    update(deltaTime) {
        if (this.isPaused) return;

        const scaledDelta = deltaTime * this.simulationSpeed;
        this.time += scaledDelta;

        this.teamA.update(scaledDelta);
        this.teamB.update(scaledDelta);
        this.ball.update(scaledDelta);
        
        this.checkPossession();
        this.executePlayerActions();
        this.checkBoundariesAndGoals();
    }
    
    checkPossession() {
        if (this.ball.carrier) return;

        let closestPlayer = null;
        let minDistance = Infinity;

        [...this.teamA.players, ...this.teamB.players].forEach(player => {
            const distance = player.position.distanceTo(this.ball.position);
            if (distance < minDistance) {
                minDistance = distance;
                closestPlayer = player;
            }
        });

        if (closestPlayer && minDistance < 1) {
            this.ball.carrier = closestPlayer;
            this.teamA.hasBall = (closestPlayer.team.id === 'A');
            this.teamB.hasBall = (closestPlayer.team.id === 'B');
            uiController.logEvent(`${closestPlayer.team.name} #${closestPlayer.number} récupère le ballon.`);
        }
    }

    executePlayerActions() {
        if (this.eventCooldown) return;
        const carrier = this.ball.carrier;
        if (!carrier) return;

        const opponentGoal = carrier.team.side === 'left' 
            ? new Vector2D(PITCH_WIDTH, PITCH_HEIGHT / 2)
            : new Vector2D(0, PITCH_HEIGHT / 2);

        const distanceToGoal = carrier.position.distanceTo(opponentGoal);
        
        if (distanceToGoal < uiController.settings.maxShotDistance) {
            this.attemptShot(carrier, opponentGoal);
        } else {
            this.attemptPass(carrier);
        }
    }

    attemptShot(shooter, goalPosition) {
        if (Math.random() > 0.1) return; // Reduce frequency of actions

        if (!shooter.useBurst(8)) {
            uiController.logEvent(`${shooter.team.name} #${shooter.number} est trop fatigué pour tirer.`);
            this.attemptPass(shooter);
            return;
        }

        const distance = shooter.position.distanceTo(goalPosition);
        const Pshot = this.calculatePshot(shooter, distance);
        uiController.logEvent(`${shooter.team.name} #${shooter.number} tire ! (Pshot: ${Pshot.toFixed(2)})`);

        if (Math.random() * 100 < Pshot) {
            this.ball.velocity = goalPosition.subtract(shooter.position).normalize().multiply(30);
        } else {
            this.ball.velocity = goalPosition.subtract(shooter.position).normalize().multiply(20 + Math.random() * 10);
            this.ball.velocity.y += (Math.random() - 0.5) * 10;
        }
        this.ball.carrier = null;
    }

    calculatePshot(shooter, distance) {
        const BaseSkill = shooter.baseSkill;
        const Ffatigue = shooter.fatigueFactor;
        const Dfactor = Math.max(0.2, 1 - (distance / (uiController.settings.maxShotDistance + 5)));
        const SituationalFactor = 1.0;
        
        return BaseSkill * Ffatigue * Dfactor * SituationalFactor;
    }
    
    attemptPass(passer) {
        if (Math.random() > 0.2) return; // Reduce frequency
        if (!passer.useBurst(1)) return;

        const teammates = passer.team.players.filter(p => p !== passer);
        let bestTarget = null;
        let minDistance = Infinity;
        teammates.forEach(t => {
            const dist = passer.position.distanceTo(t.position);
            if (dist < minDistance && dist > 2) {
                minDistance = dist;
                bestTarget = t;
            }
        });
        
        if(bestTarget) {
            const passDirection = bestTarget.position.subtract(passer.position).normalize();
            this.ball.velocity = passDirection.multiply(15 + Math.random() * 5);
            this.ball.carrier = null;
        }
    }
    
    checkBoundariesAndGoals() {
        if (this.eventCooldown) return;
        const { x, y } = this.ball.position;
        const goalYMin = (PITCH_HEIGHT / 2) - (GOAL_WIDTH / 2);
        const goalYMax = (PITCH_HEIGHT / 2) + (GOAL_WIDTH / 2);

        let eventOccurred = false;
        const scoringTeam = x < 0 ? this.teamB : (x > PITCH_WIDTH ? this.teamA : null);

        if (scoringTeam && y > goalYMin && y < goalYMax) {
            this.goalScored(scoringTeam);
            eventOccurred = true;
        } else if (x < -2 || x > PITCH_WIDTH + 2 || y < -2 || y > PITCH_HEIGHT + 2) {
             uiController.logEvent("Le ballon sort des limites. Remise en jeu.");
             this.resetPositionsAfterEvent();
             this.kickOff();
             eventOccurred = true;
        }

        if(eventOccurred) {
            this.eventCooldown = true;
            setTimeout(() => { this.eventCooldown = false; }, 2000);
        }
    }

    goalScored(scoringTeam) {
        scoringTeam.score++;
        uiController.logEvent(`BUT pour ${scoringTeam.name} !`, 'goal');
        uiController.updateScore(this.teamA.score, this.teamB.score);
        this.resetPositionsAfterEvent();
        this.kickOff();
    }
    
    resetPositionsAfterEvent() {
        this.teamA.players.forEach(p => p.position = new Vector2D(p.tactics.without_ball.position.x, p.tactics.without_ball.position.y));
        this.teamB.players.forEach(p => p.position = new Vector2D(p.tactics.without_ball.position.x, p.tactics.without_ball.position.y));
        this.isPaused = true;
    }
}

class Renderer {
    draw() {
        if (!canvas || !ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.drawPitch();
        
        if (matchEngine) {
             this.drawShootingZone(matchEngine.teamA);
             this.drawShootingZone(matchEngine.teamB);
             matchEngine.teamA.players.forEach(p => this.drawPlayer(p));
             matchEngine.teamB.players.forEach(p => this.drawPlayer(p));
             this.drawBall(matchEngine.ball);
        }
    }

    drawPitch() {
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = Math.max(1, 2 * (scale/10));
        ctx.strokeRect(0, 0, canvas.width, canvas.height);

        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2, 9.15 * scale, 0, 2 * Math.PI);
        ctx.stroke();

        this.drawBox(16.5, 40.3);
        this.drawBox(5.5, 18.3);
        
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(-2*scale, (canvasHeight/2) - (GOAL_WIDTH/2 * scale), 2*scale, GOAL_WIDTH * scale);
        ctx.fillRect(canvasWidth, (canvasHeight/2) - (GOAL_WIDTH/2 * scale), 2*scale, GOAL_WIDTH * scale);

        ctx.restore();
    }
    
    drawBox(x_m, y_m) {
        const boxWidth = x_m * scale;
        const boxHeight = y_m * scale;
        ctx.strokeRect(0, (canvasHeight - boxHeight) / 2, boxWidth, boxHeight);
        ctx.strokeRect(canvasWidth - boxWidth, (canvasHeight - boxHeight) / 2, boxWidth, boxHeight);
    }
    
    drawPlayer(player) {
        const x = player.position.x * scale;
        const y = player.position.y * scale;
        const radius = Math.max(2, (player.isGoalkeeper ? 6 : 5) * (scale/10));

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fillStyle = player.color;
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.stroke();

        if (radius > 3) {
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(4, 8 * (scale/10))}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(player.number, x, y);
        }
    }

    drawBall(ball) {
        const x = ball.position.x * scale;
        const y = ball.position.y * scale;
        
        ctx.beginPath();
        ctx.arc(x, y, Math.max(1.5, 3 * (scale/10)), 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    drawShootingZone(team) {
        const maxDist = uiController.settings.maxShotDistance * scale;
        const goalX = team.side === 'left' ? canvasWidth : 0;
        const goalY = canvasHeight / 2;

        ctx.beginPath();
        const startAngle = team.side === 'left' ? Math.PI * 1.5 : Math.PI * 0.5;
        const endAngle = team.side === 'left' ? Math.PI * 0.5 : Math.PI * 1.5;
        
        ctx.arc(goalX, goalY, maxDist, startAngle, endAngle);
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

class UIController {
    constructor() {
        this.settings = { maxShotDistance: 25, simSpeed: 1 };
        this.activeTeam = 'A';
        this.activePhase = 'with_ball';
        this.selectedPlayer = null;
        this.initEventListeners();
        this.buildTeamConfigPanel('A');
        this.buildTeamConfigPanel('B');
    }

    initEventListeners() {
        document.getElementById('start-match').addEventListener('click', () => this.startMatch());
        document.getElementById('pause-match').addEventListener('click', () => this.pauseMatch());
        document.getElementById('reset-match').addEventListener('click', () => this.resetMatch());
        
        document.getElementById('sim-speed').addEventListener('input', (e) => this.updateSimSpeed(e.target.value));
        document.getElementById('shot-distance').addEventListener('input', (e) => this.updateShotDistance(e.target.value));
        document.getElementById('tab-team-a').addEventListener('click', () => this.switchTeamTab('A'));
        document.getElementById('tab-team-b').addEventListener('click', () => this.switchTeamTab('B'));
    }
    
    startMatch() {
        matchEngine.isPaused = false;
        document.getElementById('start-match').disabled = true;
        document.getElementById('pause-match').disabled = false;
        document.getElementById('pause-match').textContent = 'Pause';
    }

    pauseMatch() {
        matchEngine.isPaused = !matchEngine.isPaused;
        document.getElementById('pause-match').textContent = matchEngine.isPaused ? 'Reprendre' : 'Pause';
    }

    resetMatch() { location.reload(); }
    
    updateSimSpeed(value) {
        this.settings.simSpeed = parseInt(value);
        if (matchEngine) matchEngine.simulationSpeed = this.settings.simSpeed;
        document.getElementById('sim-speed-value').textContent = value;
    }

    updateShotDistance(value) {
        this.settings.maxShotDistance = parseInt(value);
        document.getElementById('shot-distance-value').textContent = value;
        renderer.draw();
    }

    switchTeamTab(teamId) {
        this.activeTeam = teamId;
        this.selectedPlayer = null;
        ['A', 'B'].forEach(id => {
            document.getElementById(`tab-team-${id.toLowerCase()}`).classList.toggle('tab-active', id === teamId);
            document.getElementById(`tab-team-${id.toLowerCase()}`).classList.toggle('tab-inactive', id !== teamId);
            document.getElementById(`config-panel-team-${id.toLowerCase()}`).classList.toggle('hidden', id !== teamId);
        });
    }

    switchPhaseTab(phase) {
        this.activePhase = phase;
        this.selectedPlayer = null;
        this.buildPlayerEditor();
        document.querySelectorAll(`.phase-tab-${this.activeTeam}`).forEach(tab => {
            tab.classList.toggle('phase-active', tab.dataset.phase === phase);
            tab.classList.toggle('phase-inactive', tab.dataset.phase !== phase);
        });
        
        this.drawMinimap();
    }
    
    buildTeamConfigPanel(teamId) {
        const team = teamId === 'A' ? teamA : teamB;
        const panel = document.getElementById(`config-panel-team-${teamId}`);
        panel.innerHTML = `
            <div class="mb-4">
                <label class="font-semibold">Nom de l'équipe:</label>
                <input type="text" value="${team.name}" class="bg-gray-800 rounded p-1 w-full mt-1" id="team-name-${teamId}">
            </div>
            <div class="flex rounded-md mb-4">
                <button data-phase="with_ball" class="phase-tab-${teamId} flex-1 p-2 font-semibold rounded-l-md transition duration-300 phase-active">Avec Ballon</button>
                <button data-phase="without_ball" class="phase-tab-${teamId} flex-1 p-2 font-semibold rounded-r-md transition duration-300 phase-inactive">Sans Ballon</button>
            </div>
            <div class="bg-gray-800 p-2 rounded-lg mb-4">
                <canvas id="minimap-${teamId}" class="w-full aspect-[105/68] pitch-bg cursor-pointer"></canvas>
            </div>
            <div id="player-editor-${teamId}" class="flex-1 bg-gray-800 rounded-lg p-3 overflow-y-auto"></div>
        `;
        
        document.getElementById(`team-name-${teamId}`).addEventListener('change', e => {
            team.name = e.target.value;
            document.getElementById(`team-${teamId.toLowerCase()}-name-display`).textContent = team.name;
        });

        document.querySelectorAll(`.phase-tab-${teamId}`).forEach(tab => {
            tab.addEventListener('click', () => this.switchPhaseTab(tab.dataset.phase));
        });
        
        this.setupMinimap(teamId);
        this.buildPlayerEditor(teamId);
    }

    setupMinimap(teamId) {
        const minimapCanvas = document.getElementById(`minimap-${teamId}`);
        const team = teamId === 'A' ? teamA : teamB;
        let draggingPlayer = null;

        const getMousePos = (e) => {
            const rect = minimapCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left) * (minimapCanvas.width / rect.width),
                y: (clientY - rect.top) * (minimapCanvas.height / rect.height)
            };
        }
        
        const startDrag = (e) => {
            e.preventDefault();
            const pos = getMousePos(e);
            const minimapScale = minimapCanvas.width / PITCH_WIDTH;
            
            let clickedPlayer = null;
            let minClickDist = Infinity;
            team.players.forEach(p => {
                const playerCanvasPos = { x: p.tactics[this.activePhase].position.x * minimapScale, y: p.tactics[this.activePhase].position.y * minimapScale };
                const distance = Math.sqrt((pos.x - playerCanvasPos.x)**2 + (pos.y - playerCanvasPos.y)**2);
                if (distance < 15 && distance < minClickDist) { // Larger touch target
                    clickedPlayer = p;
                    minClickDist = distance;
                }
            });
            if (clickedPlayer) {
                 draggingPlayer = clickedPlayer;
                 this.selectedPlayer = draggingPlayer;
                 this.buildPlayerEditor();
            }
        };
        
        const drag = (e) => {
            if (draggingPlayer) {
                e.preventDefault();
                const pos = getMousePos(e);
                const minimapScale = minimapCanvas.width / PITCH_WIDTH;
                draggingPlayer.tactics[this.activePhase].position.x = Math.max(0, Math.min(PITCH_WIDTH, pos.x / minimapScale));
                draggingPlayer.tactics[this.activePhase].position.y = Math.max(0, Math.min(PITCH_HEIGHT, pos.y / minimapScale));
                this.drawMinimap();
                this.buildPlayerEditor();
            }
        };

        const endDrag = () => { draggingPlayer = null; };

        minimapCanvas.addEventListener('mousedown', startDrag);
        minimapCanvas.addEventListener('mousemove', drag);
        minimapCanvas.addEventListener('mouseup', endDrag);
        minimapCanvas.addEventListener('mouseleave', endDrag);

        minimapCanvas.addEventListener('touchstart', startDrag, { passive: false });
        minimapCanvas.addEventListener('touchmove', drag, { passive: false });
        minimapCanvas.addEventListener('touchend', endDrag);
    }
    
    drawMinimap(teamId = this.activeTeam) {
        const minimapCanvas = document.getElementById(`minimap-${teamId}`);
        if(!minimapCanvas) return;
        const miniCtx = minimapCanvas.getContext('2d');
        const team = teamId === 'A' ? teamA : teamB;
        
        minimapCanvas.width = minimapCanvas.clientWidth;
        minimapCanvas.height = minimapCanvas.clientHeight;
        const minimapScale = minimapCanvas.width / PITCH_WIDTH;
        
        miniCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        
        team.players.forEach(p => {
            const pos = p.tactics[this.activePhase].position;
            const x = pos.x * minimapScale;
            const y = pos.y * minimapScale;
            
            miniCtx.beginPath();
            miniCtx.arc(x, y, 4, 0, 2 * Math.PI);
            miniCtx.fillStyle = p.color;
            miniCtx.fill();

            if (p === this.selectedPlayer) {
                miniCtx.strokeStyle = '#f7b731';
                miniCtx.lineWidth = 2;
                miniCtx.stroke();
            }

            miniCtx.fillStyle = 'white';
            miniCtx.font = 'bold 7px Arial';
            miniCtx.textAlign = 'center';
            miniCtx.textBaseline = 'middle';
            miniCtx.fillText(p.number, x, y);
        });
    }
    
    buildPlayerEditor(teamId = this.activeTeam) {
        const panel = document.getElementById(`player-editor-${teamId}`);
        if (!panel) return;
        if (!this.selectedPlayer) {
            panel.innerHTML = '<p class="text-gray-400 text-center p-4">Cliquez sur un joueur sur la mini-carte pour le configurer.</p>';
            return;
        }
        const player = this.selectedPlayer;
        const playerPos = player.tactics[this.activePhase].position;
        panel.innerHTML = `
            <h3 class="text-lg font-bold text-yellow-400">Configuration Joueur #${player.number}</h3>
            <div class="mt-2 space-y-3">
                 <div>
                    <label class="block text-sm font-medium">Position (X: ${playerPos.x.toFixed(1)}, Y: ${playerPos.y.toFixed(1)})</label>
                </div>
                <div>
                    <label for="player-skill" class="block text-sm font-medium">Compétence de base: <span id="player-skill-value">${player.baseSkill}</span></label>
                    <input id="player-skill" type="range" min="1" max="100" value="${player.baseSkill}" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
                 <div class="mt-2">
                     <h4 class="font-semibold">Instructions pour la phase (${this.activePhase.replace('_', ' ')}):</h4>
                     <div class="text-sm mt-2 text-gray-300"><p>Fonctionnalité à venir...</p></div>
                </div>
            </div>
        `;
        document.getElementById('player-skill').addEventListener('input', e => {
            player.baseSkill = parseInt(e.target.value);
            document.getElementById('player-skill-value').textContent = player.baseSkill;
        });
    }

    logEvent(message, type = 'info') {
        const log = document.getElementById('event-log');
        const time = matchEngine ? (matchEngine.time / 60).toFixed(0).padStart(2, '0') : '00';
        const p = document.createElement('p');
        p.textContent = `${time}': ${message}`;
        if (type === 'goal') p.className = 'text-yellow-300 font-bold';
        log.appendChild(p);
        log.scrollTop = log.scrollHeight;
    }

    updateScore(scoreA, scoreB) {
        document.getElementById('score-display').innerHTML = `
            <span class="text-blue-400">${teamA.name}</span> ${scoreA} - ${scoreB} <span class="text-red-400">${teamB.name}</span>
        `;
    }

    updateTime(seconds) {
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
        document.getElementById('time-display').textContent = `${mins}:${secs}`;
    }
}

// -----------------------------------------------------------------------------------
// Section 5: Boucle principale et initialisation
// -----------------------------------------------------------------------------------

let teamA = new Team('A', 'Équipe A', '#3b82f6', 'left');
let teamB = new Team('B', 'Équipe B', '#ef4444', 'right');
let matchEngine = new MatchEngine(teamA, teamB);
let renderer = new Renderer();
let uiController = new UIController();

let lastTime = 0;
function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (matchEngine && !matchEngine.isPaused) {
        matchEngine.update(deltaTime || 0);
    }
    renderer.draw();
    uiController.updateTime(matchEngine.time);
    
    requestAnimationFrame(gameLoop);
}

window.addEventListener('load', () => {
    // Initial resize and draw
    resizeCanvas();
    uiController.drawMinimap('A'); 
    uiController.drawMinimap('B');

    // Use ResizeObserver for efficient resize handling
    const mainArea = document.querySelector('main');
    const resizeObserver = new ResizeObserver(entries => {
        resizeCanvas();
        uiController.drawMinimap('A');
        uiController.drawMinimap('B');
    });
    if (mainArea) {
       resizeObserver.observe(mainArea);
    }

    uiController.logEvent("Bienvenue ! Configurez vos équipes et lancez le match.");
    requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>

