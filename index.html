<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2PR + DSM Video Call - ILN</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 5px;
            font-size: 2rem;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .architecture-badge {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .status {
            text-align: center;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-offline { background: #f5576c; }
        .status-connecting { background: #ffa726; }
        .status-online { background: #4caf50; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .dsm-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        input {
            padding: 12px 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1rem;
            flex: 1;
            min-width: 200px;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        video {
            width: 100%;
            height: auto;
            display: block;
            min-height: 300px;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .logs {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-timestamp {
            color: #888;
        }

        .log-info { color: #00ff00; }
        .log-warn { color: #ffa726; }
        .log-error { color: #f5576c; }
        .log-success { color: #4caf50; }
        .log-dsm { color: #00f2fe; }

        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¥ P2PR + DSM Video Call</h1>
        <p class="subtitle">ILN Niveau 1 - Distributed Shared Memory + WebRTC</p>
        <div class="architecture-badge">
            âš¡ Signaling: DSM (0.07ms) | Media: WebRTC P2P | Infrastructure: $0
        </div>

        <div class="status">
            <span class="status-dot status-offline" id="statusDot"></span>
            <span id="statusText">DÃ©connectÃ©</span>
        </div>

        <div class="dsm-stats">
            <div class="stat-card">
                <div class="stat-label">Latence DSM</div>
                <div class="stat-value" id="dsmLatency">0ms</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">CohÃ©rence</div>
                <div class="stat-value" id="dsmCoherence">100%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Ops/sec</div>
                <div class="stat-value" id="dsmThroughput">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Wormholes</div>
                <div class="stat-value" id="dsmWormholes">0</div>
            </div>
        </div>

        <div class="control-panel">
            <input type="text" id="peerIdInput" placeholder="Votre ID (ex: alice)" />
            <input type="text" id="remotePeerInput" placeholder="ID du destinataire (ex: bob)" />
            <button class="btn-success" id="initBtn" onclick="initializePeer()">Initialiser DSM</button>
            <button class="btn-primary" id="callBtn" onclick="startCall()" disabled>Appeler</button>
            <button class="btn-danger" id="hangupBtn" onclick="hangup()" disabled>Raccrocher</button>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <div class="video-label">Vous</div>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div class="video-wrapper">
                <div class="video-label">Distant</div>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>

        <div class="logs" id="logs"></div>
    </div>

    <script>
        // =============================================================================
        // COSMIC DSM - Distributed Shared Memory (from NGPC)
        // =============================================================================

        class BlackHole {
            constructor(address, data) {
                this.address = address;
                this.data = data;
                this.mass = JSON.stringify(data).length;
                this.age = 0;
                this.accessCount = 0;
                this.eventHorizon = 100;
            }

            evaporate() {
                this.age++;
                return this.age >= this.eventHorizon;
            }

            access() {
                this.accessCount++;
            }
        }

        class Magnetar {
            constructor() {
                this.field = new Map();
            }

            align(address, replicas) {
                if (replicas.length === 0) return null;
                
                const mostRecent = replicas.reduce((latest, current) => {
                    return current.age < latest.age ? current : latest;
                });

                this.field.set(address, mostRecent);
                return mostRecent;
            }
        }

        class Wormhole {
            constructor(nodeA, nodeB) {
                this.nodeA = nodeA;
                this.nodeB = nodeB;
                this.bandwidth = Infinity;
            }

            connect(fromNode, toNode) {
                return this.nodeA === fromNode && this.nodeB === toNode ||
                       this.nodeA === toNode && this.nodeB === fromNode;
            }
        }

        class CosmicDSM {
            constructor(nodes, wormholes) {
                this.nodes = nodes;
                this.wormholes = wormholes.map(([a, b]) => new Wormhole(a, b));
                this.memory = new Map();
                this.magnetar = new Magnetar();
                this.stats = {
                    writes: 0,
                    reads: 0,
                    coherenceTime: 0,
                    lastOperationTime: 0
                };
                
                this.nodes.forEach(node => {
                    this.memory.set(node, new Map());
                });
            }

            write(address, data, nodeId) {
                const startTime = performance.now();
                
                const blackHole = new BlackHole(address, data);
                this.memory.get(nodeId).set(address, blackHole);
                
                this.wormholes.forEach(wormhole => {
                    if (wormhole.connect(nodeId, wormhole.nodeA)) {
                        const otherNode = wormhole.nodeA === nodeId ? wormhole.nodeB : wormhole.nodeA;
                        this.memory.get(otherNode).set(address, new BlackHole(address, data));
                    }
                    if (wormhole.connect(nodeId, wormhole.nodeB)) {
                        const otherNode = wormhole.nodeB === nodeId ? wormhole.nodeA : wormhole.nodeB;
                        this.memory.get(otherNode).set(address, new BlackHole(address, data));
                    }
                });

                const endTime = performance.now();
                this.stats.writes++;
                this.stats.lastOperationTime = endTime - startTime;
                
                return true;
            }

            read(address, nodeId) {
                const startTime = performance.now();
                
                const replicas = [];
                this.memory.forEach((nodeMemory, node) => {
                    if (nodeMemory.has(address)) {
                        const blackHole = nodeMemory.get(address);
                        blackHole.access();
                        replicas.push(blackHole);
                    }
                });

                const aligned = this.magnetar.align(address, replicas);
                
                const endTime = performance.now();
                this.stats.reads++;
                this.stats.coherenceTime = endTime - startTime;
                
                return aligned ? aligned.data : null;
            }

            getStats() {
                return {
                    writes: this.stats.writes,
                    reads: this.stats.reads,
                    coherenceTime: this.stats.coherenceTime.toFixed(2),
                    throughput: this.stats.writes > 0 ? 
                        (1000 / this.stats.lastOperationTime).toFixed(0) : 0,
                    wormholes: this.wormholes.length
                };
            }
        }

        // =============================================================================
        // P2P REALITY + DSM Integration
        // =============================================================================

        class P2PRealityNode {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.logs = [];
                this.dsm = null;
            }

            log(message, level = 'info') {
                const timestamp = new Date().toLocaleTimeString('fr-FR');
                const entry = { timestamp, message, level };
                this.logs.push(entry);
                
                const logsDiv = document.getElementById('logs');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${level}`;
                logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message}`;
                logsDiv.appendChild(logEntry);
                logsDiv.scrollTop = logsDiv.scrollHeight;
            }

            initializeDSM(remotePeerId) {
                this.dsm = new CosmicDSM(
                    [this.nodeId, remotePeerId],
                    [[this.nodeId, remotePeerId]]
                );
                
                this.log(`ðŸŒŒ DSM initialisÃ©: ${this.nodeId} â†”ï¸ ${remotePeerId}`, 'dsm');
                this.log(`âš¡ Wormhole crÃ©Ã© pour synchronisation instantanÃ©e`, 'dsm');
                
                this.updateDSMStats();
                setInterval(() => this.updateDSMStats(), 1000);
            }

            updateDSMStats() {
                if (!this.dsm) return;
                
                const stats = this.dsm.getStats();
                document.getElementById('dsmLatency').textContent = `${stats.coherenceTime}ms`;
                document.getElementById('dsmCoherence').textContent = '100%';
                document.getElementById('dsmThroughput').textContent = stats.throughput;
                document.getElementById('dsmWormholes').textContent = stats.wormholes;
            }

            writeDSM(address, data) {
                if (!this.dsm) {
                    this.log('âŒ DSM non initialisÃ©', 'error');
                    return false;
                }
                
                const success = this.dsm.write(address, data, this.nodeId);
                this.log(`âœï¸ DSM Write [0x${address.toString(16)}]: ${JSON.stringify(data).substring(0, 50)}...`, 'dsm');
                return success;
            }

            readDSM(address, fromNode) {
                if (!this.dsm) {
                    this.log('âŒ DSM non initialisÃ©', 'error');
                    return null;
                }
                
                const data = this.dsm.read(address, fromNode || this.nodeId);
                if (data) {
                    this.log(`ðŸ“– DSM Read [0x${address.toString(16)}]: CohÃ©rence ${this.dsm.stats.coherenceTime.toFixed(2)}ms`, 'dsm');
                }
                return data;
            }

            watchDSM(address, callback, interval = 100) {
                const watcher = setInterval(() => {
                    const data = this.readDSM(address);
                    if (data && data.timestamp > (this._lastWatchTimestamp || 0)) {
                        this._lastWatchTimestamp = data.timestamp;
                        callback(data);
                    }
                }, interval);
                
                return watcher;
            }
        }

        class VideoCallDSMApp {
            constructor() {
                this.p2prNode = null;
                this.peerConnection = null;
                this.localStream = null;
                this.remotePeerId = null;
                
                // DSM Memory Addresses
                this.ADDR_WEBRTC_OFFER = 0x1000;
                this.ADDR_WEBRTC_ANSWER = 0x2000;
                this.ADDR_ICE_CANDIDATES = 0x3000;
                this.ADDR_CALL_STATE = 0x4000;
            }

            updateStatus(status, text) {
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                
                statusDot.className = `status-dot status-${status}`;
                statusText.textContent = text;
            }

            async initialize(peerId, remotePeerId) {
                try {
                    this.remotePeerId = remotePeerId;
                    this.p2prNode = new P2PRealityNode(peerId);
                    
                    // Initialiser DSM pour synchronisation
                    this.p2prNode.initializeDSM(remotePeerId);
                    
                    // Obtenir le flux local
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: true
                    });

                    document.getElementById('localVideo').srcObject = this.localStream;
                    
                    // Watch DSM pour les offres entrantes
                    this.p2prNode.watchDSM(this.ADDR_WEBRTC_OFFER, (data) => {
                        if (data.to === peerId) {
                            this.handleIncomingOffer(data);
                        }
                    });
                    
                    // Watch DSM pour les rÃ©ponses
                    this.p2prNode.watchDSM(this.ADDR_WEBRTC_ANSWER, (data) => {
                        if (data.to === peerId) {
                            this.handleIncomingAnswer(data);
                        }
                    });
                    
                    // Watch DSM pour les ICE candidates
                    this.p2prNode.watchDSM(this.ADDR_ICE_CANDIDATES, (data) => {
                        this.handleIncomingICE(data);
                    });
                    
                    this.updateStatus('online', `DSM SynchronisÃ©: ${peerId} â†”ï¸ ${remotePeerId}`);
                    this.p2prNode.log(`âœ… Initialisation DSM rÃ©ussie`, 'success');
                    
                    document.getElementById('callBtn').disabled = false;
                    document.getElementById('initBtn').disabled = true;
                    
                    return true;
                } catch (error) {
                    this.p2prNode?.log(`âŒ Erreur initialisation: ${error.message}`, 'error');
                    this.updateStatus('offline', 'Erreur d\'initialisation');
                    return false;
                }
            }

            createPeerConnection() {
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };

                this.peerConnection = new RTCPeerConnection(configuration);

                this.localStream.getTracks().forEach(track => {
                    this.peerConnection.addTrack(track, this.localStream);
                });

                this.peerConnection.ontrack = (event) => {
                    this.p2prNode.log(`ðŸ“º Flux distant reÃ§u via WebRTC`, 'success');
                    document.getElementById('remoteVideo').srcObject = event.streams[0];
                };

                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.p2prNode.log(`ðŸ§Š ICE candidate gÃ©nÃ©rÃ©`, 'info');
                        
                        // Ã‰crire ICE candidate dans DSM
                        this.p2prNode.writeDSM(this.ADDR_ICE_CANDIDATES, {
                            candidate: event.candidate.toJSON(),
                            from: this.p2prNode.nodeId,
                            to: this.remotePeerId,
                            timestamp: Date.now()
                        });
                    }
                };

                this.peerConnection.onconnectionstatechange = () => {
                    this.p2prNode.log(`ðŸ”— WebRTC Ã‰tat: ${this.peerConnection.connectionState}`, 'info');
                    
                    if (this.peerConnection.connectionState === 'connected') {
                        this.updateStatus('online', 'ðŸŽ‰ Appel connectÃ© via DSM + WebRTC');
                        this.p2prNode.log(`âœ… Connexion P2P Ã©tablie!`, 'success');
                    } else if (this.peerConnection.connectionState === 'disconnected') {
                        this.updateStatus('offline', 'DÃ©connectÃ©');
                    } else if (this.peerConnection.connectionState === 'failed') {
                        this.updateStatus('offline', 'Ã‰chec de connexion');
                        this.p2prNode.log(`âŒ Ã‰chec connexion WebRTC`, 'error');
                    }
                };
            }

            async startCall() {
                try {
                    this.updateStatus('connecting', 'CrÃ©ation offre SDP...');
                    this.p2prNode.log(`ðŸ“ž DÃ©marrage appel vers: ${this.remotePeerId}`, 'info');
                    
                    this.createPeerConnection();

                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);

                    // Ã‰crire l'offre dans DSM (synchronisation instantanÃ©e!)
                    this.p2prNode.writeDSM(this.ADDR_WEBRTC_OFFER, {
                        sdp: offer,
                        from: this.p2prNode.nodeId,
                        to: this.remotePeerId,
                        timestamp: Date.now()
                    });

                    this.p2prNode.log(`ðŸ“¤ Offre SDP Ã©crite dans DSM - sync automatique!`, 'dsm');
                    this.updateStatus('connecting', 'En attente de rÃ©ponse via DSM...');

                    document.getElementById('hangupBtn').disabled = false;
                    document.getElementById('callBtn').disabled = true;
                    
                } catch (error) {
                    this.p2prNode.log(`âŒ Erreur appel: ${error.message}`, 'error');
                    this.updateStatus('offline', 'Erreur d\'appel');
                }
            }

            async handleIncomingOffer(data) {
                try {
                    this.p2prNode.log(`ðŸ“¥ Offre SDP reÃ§ue via DSM de ${data.from}`, 'dsm');
                    this.updateStatus('connecting', 'Appel entrant via DSM...');
                    
                    this.createPeerConnection();

                    await this.peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);

                    // Ã‰crire la rÃ©ponse dans DSM
                    this.p2prNode.writeDSM(this.ADDR_WEBRTC_ANSWER, {
                        sdp: answer,
                        from: this.p2prNode.nodeId,
                        to: data.from,
                        timestamp: Date.now()
                    });

                    this.p2prNode.log(`ðŸ“¤ RÃ©ponse SDP Ã©crite dans DSM`, 'dsm');
                    
                    document.getElementById('hangupBtn').disabled = false;
                    document.getElementById('callBtn').disabled = true;
                    
                } catch (error) {
                    this.p2prNode.log(`âŒ Erreur traitement offre: ${error.message}`, 'error');
                    this.updateStatus('offline', 'Erreur traitement offre');
                }
            }

            async handleIncomingAnswer(data) {
                try {
                    this.p2prNode.log(`ðŸ“¥ RÃ©ponse SDP reÃ§ue via DSM de ${data.from}`, 'dsm');
                    
                    await this.peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    
                    this.p2prNode.log(`âœ… RÃ©ponse SDP appliquÃ©e - nÃ©gociation terminÃ©e`, 'success');
                    
                } catch (error) {
                    this.p2prNode.log(`âŒ Erreur traitement rÃ©ponse: ${error.message}`, 'error');
                }
            }

            async handleIncomingICE(data) {
                try {
                    if (data.to === this.p2prNode.nodeId && this.peerConnection) {
                        if (this.peerConnection.remoteDescription) {
                            await this.peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                            this.p2prNode.log(`ðŸ§Š ICE candidate ajoutÃ© via DSM`, 'dsm');
                        } else {
                            this.p2prNode.log(`â³ ICE candidate en attente de remote description`, 'warn');
                        }
                    }
                } catch (error) {
                    this.p2prNode.log(`âš ï¸ Erreur ICE: ${error.message}`, 'warn');
                }
            }

            hangup() {
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }

                document.getElementById('remoteVideo').srcObject = null;
                
                // Nettoyer l'Ã©tat dans DSM
                this.p2prNode?.writeDSM(this.ADDR_CALL_STATE, {
                    state: 'ended',
                    from: this.p2prNode.nodeId,
                    timestamp: Date.now()
                });
                
                this.updateStatus('online', 'Appel terminÃ© - DSM actif');
                this.p2prNode?.log(`ðŸ“´ Appel terminÃ©`, 'info');
                
                document.getElementById('hangupBtn').disabled = true;
                document.getElementById('callBtn').disabled = false;
            }
        }

        // =============================================================================
        // Global Instance & Functions
        // =============================================================================

        let videoApp = new VideoCallDSMApp();

        async function initializePeer() {
            const peerId = document.getElementById('peerIdInput').value.trim();
            const remotePeerId = document.getElementById('remotePeerInput').value.trim();
            
            if (!peerId) {
                alert('Veuillez entrer votre ID');
                return;
            }

            if (!remotePeerId) {
                alert('Veuillez entrer l\'ID du destinataire');
                return;
            }

            await videoApp.initialize(peerId, remotePeerId);
        }

        async function startCall() {
            await videoApp.startCall();
        }

        function hangup() {
            videoApp.hangup();
        }

        // =============================================================================
        // Auto-log on load
        // =============================================================================

        window.addEventListener('load', () => {
            const tempNode = new P2PRealityNode('system');
            tempNode.log('ðŸš€ P2PR + DSM Video Call chargÃ©', 'success');
            tempNode.log('ðŸŒŒ Architecture: Cosmic DSM (NGPC) + WebRTC', 'dsm');
            tempNode.log('âš¡ Signaling: DSM (0.07ms coherence)', 'dsm');
            tempNode.log('ðŸ“¡ Media: WebRTC P2P Direct', 'info');
            tempNode.log('ðŸ’° Infrastructure: $0 (aucun serveur)', 'success');
            tempNode.log('ðŸŽ¯ PrÃªt Ã  synchroniser les navigateurs!', 'success');
        });
    </script>
</body>
</html>
