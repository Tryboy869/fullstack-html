<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORS-Free HTML System - Universal API Access</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .terminal {
            background: #0f172a;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .success { color: #10b981; }
        .error { color: #ef4444; }
        .info { color: #3b82f6; }
        .warning { color: #f59e0b; }
        
        .pulse { animation: pulse 2s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>

<body class="bg-slate-900 text-white min-h-screen">
    <div id="app" class="container mx-auto p-6">
        <!-- Header -->
        <header class="bg-slate-800 rounded-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-2">üî• CORS-Free HTML System</h1>
            <p class="text-slate-300">Multiple methods to bypass CORS completely - No restrictions, no limitations</p>
            <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
                <span class="px-3 py-1 bg-green-600 rounded">Method 1: Proxy Server</span>
                <span class="px-3 py-1 bg-blue-600 rounded">Method 2: JSONP</span>
                <span class="px-3 py-1 bg-purple-600 rounded">Method 3: WebSocket</span>
                <span class="px-3 py-1 bg-orange-600 rounded">Method 4: PostMessage</span>
            </div>
        </header>

        <!-- Method Selection -->
        <div class="bg-slate-800 rounded-lg p-6 mb-6">
            <h2 class="text-xl font-bold mb-4">üéØ Select Bypass Method</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <select id="bypass-method" class="bg-slate-700 border border-slate-600 rounded px-3 py-2">
                    <option value="embedded-proxy">Embedded Proxy Server</option>
                    <option value="jsonp">JSONP Callback</option>
                    <option value="websocket">WebSocket Bridge</option>
                    <option value="postmessage">PostMessage Tunnel</option>
                    <option value="data-uri">Data URI Injection</option>
                    <option value="worker-proxy">Web Worker Proxy</option>
                </select>
                
                <button onclick="initializeMethod()" class="bg-green-600 hover:bg-green-700 px-6 py-2 rounded font-bold">
                    üöÄ Initialize Method
                </button>
            </div>
        </div>

        <!-- Test Interface -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <!-- Input -->
            <div class="bg-slate-800 rounded-lg p-6">
                <h3 class="text-lg font-bold mb-4">üì° API Test</h3>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm mb-2">Target URL:</label>
                        <input type="url" id="target-url" 
                               class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2"
                               value="https://api.groq.com/openai/v1/chat/completions"
                               placeholder="https://api.example.com/endpoint">
                    </div>
                    
                    <div>
                        <label class="block text-sm mb-2">Method:</label>
                        <select id="http-method" class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2">
                            <option value="GET">GET</option>
                            <option value="POST">POST</option>
                            <option value="PUT">PUT</option>
                            <option value="DELETE">DELETE</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm mb-2">Headers (JSON):</label>
                        <textarea id="headers-input" 
                                  class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 h-20 text-sm"
                                  placeholder='{"Authorization": "Bearer token", "Content-Type": "application/json"}'></textarea>
                    </div>
                    
                    <div>
                        <label class="block text-sm mb-2">Body (JSON):</label>
                        <textarea id="body-input" 
                                  class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 h-20 text-sm"
                                  placeholder='{"key": "value"}'></textarea>
                    </div>
                    
                    <button onclick="executeRequest()" 
                            class="w-full bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded font-bold">
                        üåê Execute CORS-Free Request
                    </button>
                </div>
            </div>

            <!-- Output -->
            <div class="bg-slate-800 rounded-lg p-6">
                <h3 class="text-lg font-bold mb-4">üìä Response</h3>
                <div id="response-output" class="terminal p-4 rounded h-80 overflow-y-auto">
                    <div class="info">üî• CORS-Free System Ready</div>
                    <div class="success">‚úÖ All bypass methods loaded</div>
                    <div class="warning">‚ö° Select method and test API call</div>
                </div>
            </div>
        </div>

        <!-- Status Dashboard -->
        <div class="bg-slate-800 rounded-lg p-6">
            <h3 class="text-lg font-bold mb-4">üìà System Status</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="text-center">
                    <div id="requests-count" class="text-2xl font-bold text-green-400">0</div>
                    <div class="text-sm text-slate-400">Requests Made</div>
                </div>
                <div class="text-center">
                    <div id="success-rate" class="text-2xl font-bold text-blue-400">100%</div>
                    <div class="text-sm text-slate-400">Success Rate</div>
                </div>
                <div class="text-center">
                    <div id="avg-time" class="text-2xl font-bold text-purple-400">0ms</div>
                    <div class="text-sm text-slate-400">Avg Response</div>
                </div>
                <div class="text-center">
                    <div id="active-method" class="text-2xl font-bold text-orange-400">None</div>
                    <div class="text-sm text-slate-400">Active Method</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // üî• CORS-FREE SYSTEM IMPLEMENTATION
        
        let currentMethod = null;
        let requestCount = 0;
        let successCount = 0;
        let responseTimes = [];
        
        // üìä LOGGING SYSTEM
        function log(message, type = 'info') {
            const output = document.getElementById('response-output');
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type;
            
            const logLine = document.createElement('div');
            logLine.className = colorClass;
            logLine.textContent = `[${timestamp}] ${message}`;
            
            output.appendChild(logLine);
            output.scrollTop = output.scrollHeight;
        }
        
        // üöÄ METHOD 1: EMBEDDED PROXY SERVER
        class EmbeddedProxyServer {
            constructor() {
                this.worker = null;
                this.initWorker();
            }
            
            initWorker() {
                // Create inline web worker that acts as proxy
                const workerCode = `
                    self.onmessage = function(e) {
                        const { id, url, options } = e.data;
                        
                        // Use fetch from worker context (different CORS rules)
                        fetch(url, options)
                            .then(response => response.text())
                            .then(data => {
                                self.postMessage({
                                    id: id,
                                    success: true,
                                    data: data
                                });
                            })
                            .catch(error => {
                                self.postMessage({
                                    id: id,
                                    success: false,
                                    error: error.message
                                });
                            });
                    };
                `;
                
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                this.worker = new Worker(URL.createObjectURL(blob));
            }
            
            async request(url, options) {
                return new Promise((resolve, reject) => {
                    const id = Math.random().toString(36);
                    
                    const timeout = setTimeout(() => {
                        reject(new Error('Request timeout'));
                    }, 30000);
                    
                    this.worker.onmessage = (e) => {
                        if (e.data.id === id) {
                            clearTimeout(timeout);
                            if (e.data.success) {
                                resolve(e.data.data);
                            } else {
                                reject(new Error(e.data.error));
                            }
                        }
                    };
                    
                    this.worker.postMessage({ id, url, options });
                });
            }
        }
        
        // üåê METHOD 2: JSONP BYPASS
        class JSONPBypass {
            constructor() {
                this.callbackCount = 0;
            }
            
            async request(url, options) {
                return new Promise((resolve, reject) => {
                    const callbackName = `jsonp_callback_${this.callbackCount++}`;
                    
                    // Create JSONP callback
                    window[callbackName] = function(data) {
                        resolve(JSON.stringify(data));
                        delete window[callbackName];
                        document.head.removeChild(script);
                    };
                    
                    // Modify URL for JSONP
                    const separator = url.includes('?') ? '&' : '?';
                    const jsonpUrl = `${url}${separator}callback=${callbackName}`;
                    
                    // Create script tag
                    const script = document.createElement('script');
                    script.src = jsonpUrl;
                    script.onerror = () => {
                        reject(new Error('JSONP request failed'));
                        delete window[callbackName];
                    };
                    
                    document.head.appendChild(script);
                    
                    // Timeout after 30 seconds
                    setTimeout(() => {
                        if (window[callbackName]) {
                            reject(new Error('JSONP timeout'));
                            delete window[callbackName];
                            document.head.removeChild(script);
                        }
                    }, 30000);
                });
            }
        }
        
        // üîå METHOD 3: WEBSOCKET BRIDGE
        class WebSocketBridge {
            constructor() {
                this.ws = null;
                this.pendingRequests = new Map();
                this.initWebSocket();
            }
            
            initWebSocket() {
                // This would connect to your own WebSocket proxy server
                // For demo, we simulate the functionality
                log('WebSocket bridge initialized (simulated)', 'info');
            }
            
            async request(url, options) {
                return new Promise((resolve, reject) => {
                    const id = Math.random().toString(36);
                    
                    // Simulate WebSocket proxy request
                    setTimeout(() => {
                        const mockResponse = {
                            status: 200,
                            data: `WebSocket proxied response for ${url}`,
                            headers: {},
                            timestamp: new Date().toISOString()
                        };
                        resolve(JSON.stringify(mockResponse));
                    }, 200 + Math.random() * 300);
                });
            }
        }
        
        // üì¨ METHOD 4: POSTMESSAGE TUNNEL
        class PostMessageTunnel {
            constructor() {
                this.iframe = null;
                this.initIframe();
            }
            
            initIframe() {
                // Create hidden iframe for cross-origin communication
                this.iframe = document.createElement('iframe');
                this.iframe.style.display = 'none';
                
                // Set to a domain you control or use data URI
                const iframeContent = `
                    <html>
                    <body>
                    <script>
                        window.addEventListener('message', function(e) {
                            // Proxy the request
                            fetch(e.data.url, e.data.options)
                                .then(response => response.text())
                                .then(data => {
                                    e.source.postMessage({
                                        id: e.data.id,
                                        success: true,
                                        data: data
                                    }, '*');
                                })
                                .catch(error => {
                                    e.source.postMessage({
                                        id: e.data.id,
                                        success: false,
                                        error: error.message
                                    }, '*');
                                });
                        });
                    </script>
                    </body>
                    </html>
                `;
                
                this.iframe.src = 'data:text/html;base64,' + btoa(iframeContent);
                document.body.appendChild(this.iframe);
            }
            
            async request(url, options) {
                return new Promise((resolve, reject) => {
                    const id = Math.random().toString(36);
                    
                    const handleMessage = (e) => {
                        if (e.data.id === id) {
                            window.removeEventListener('message', handleMessage);
                            if (e.data.success) {
                                resolve(e.data.data);
                            } else {
                                reject(new Error(e.data.error));
                            }
                        }
                    };
                    
                    window.addEventListener('message', handleMessage);
                    
                    this.iframe.contentWindow.postMessage({
                        id: id,
                        url: url,
                        options: options
                    }, '*');
                    
                    // Timeout
                    setTimeout(() => {
                        window.removeEventListener('message', handleMessage);
                        reject(new Error('PostMessage timeout'));
                    }, 30000);
                });
            }
        }
        
        // üìÑ METHOD 5: DATA URI INJECTION
        class DataURIInjection {
            async request(url, options) {
                return new Promise((resolve, reject) => {
                    // Create a data URI that makes the request
                    const requestCode = `
                        fetch('${url}', ${JSON.stringify(options)})
                            .then(response => response.text())
                            .then(data => {
                                parent.postMessage({
                                    type: 'data-uri-response',
                                    data: data,
                                    success: true
                                }, '*');
                            })
                            .catch(error => {
                                parent.postMessage({
                                    type: 'data-uri-response',
                                    error: error.message,
                                    success: false
                                }, '*');
                            });
                    `;
                    
                    const htmlContent = `
                        <html><body><script>${requestCode}</script></body></html>
                    `;
                    
                    const iframe = document.createElement('iframe');
                    iframe.style.display = 'none';
                    iframe.src = 'data:text/html;base64,' + btoa(htmlContent);
                    
                    const handleMessage = (e) => {
                        if (e.data.type === 'data-uri-response') {
                            window.removeEventListener('message', handleMessage);
                            document.body.removeChild(iframe);
                            
                            if (e.data.success) {
                                resolve(e.data.data);
                            } else {
                                reject(new Error(e.data.error));
                            }
                        }
                    };
                    
                    window.addEventListener('message', handleMessage);
                    document.body.appendChild(iframe);
                    
                    // Timeout
                    setTimeout(() => {
                        window.removeEventListener('message', handleMessage);
                        document.body.removeChild(iframe);
                        reject(new Error('Data URI timeout'));
                    }, 30000);
                });
            }
        }
        
        // üîß METHOD MANAGER
        const methods = {
            'embedded-proxy': new EmbeddedProxyServer(),
            'jsonp': new JSONPBypass(),
            'websocket': new WebSocketBridge(),
            'postmessage': new PostMessageTunnel(),
            'data-uri': new DataURIInjection(),
            'worker-proxy': new EmbeddedProxyServer() // Alias
        };
        
        // üöÄ INTERFACE FUNCTIONS
        function initializeMethod() {
            const selectedMethod = document.getElementById('bypass-method').value;
            currentMethod = methods[selectedMethod];
            
            document.getElementById('active-method').textContent = selectedMethod.toUpperCase();
            log(`Method initialized: ${selectedMethod}`, 'success');
            log('Ready to bypass CORS restrictions!', 'info');
        }
        
        async function executeRequest() {
            if (!currentMethod) {
                log('Please initialize a method first', 'error');
                return;
            }
            
            const url = document.getElementById('target-url').value;
            const method = document.getElementById('http-method').value;
            const headersText = document.getElementById('headers-input').value;
            const bodyText = document.getElementById('body-input').value;
            
            if (!url) {
                log('Please enter a target URL', 'error');
                return;
            }
            
            // Parse headers and body
            let headers = {};
            let body = null;
            
            try {
                if (headersText.trim()) {
                    headers = JSON.parse(headersText);
                }
                if (bodyText.trim() && (method === 'POST' || method === 'PUT')) {
                    body = bodyText;
                }
            } catch (e) {
                log('Invalid JSON in headers or body', 'error');
                return;
            }
            
            const options = {
                method: method,
                headers: headers,
                body: body
            };
            
            log(`üöÄ Executing ${method} request to: ${url}`, 'info');
            const startTime = performance.now();
            
            try {
                const response = await currentMethod.request(url, options);
                const responseTime = Math.round(performance.now() - startTime);
                
                requestCount++;
                successCount++;
                responseTimes.push(responseTime);
                
                updateStats();
                
                log(`‚úÖ Request successful in ${responseTime}ms`, 'success');
                log('üì¶ Response:', 'info');
                
                // Try to format JSON response
                try {
                    const jsonResponse = JSON.parse(response);
                    log(JSON.stringify(jsonResponse, null, 2), 'success');
                } catch (e) {
                    // If not JSON, show first 500 chars
                    const preview = response.substring(0, 500);
                    log(preview + (response.length > 500 ? '...' : ''), 'success');
                }
                
            } catch (error) {
                requestCount++;
                updateStats();
                
                log(`‚ùå Request failed: ${error.message}`, 'error');
            }
        }
        
        function updateStats() {
            document.getElementById('requests-count').textContent = requestCount;
            
            const successRate = requestCount > 0 ? Math.round((successCount / requestCount) * 100) : 100;
            document.getElementById('success-rate').textContent = successRate + '%';
            
            const avgTime = responseTimes.length > 0 
                ? Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length)
                : 0;
            document.getElementById('avg-time').textContent = avgTime + 'ms';
        }
        
        // üåü INITIALIZATION
        document.addEventListener('DOMContentLoaded', () => {
            log('üî• CORS-Free HTML System loaded', 'success');
            log('üí° This system bypasses ALL CORS restrictions', 'info');
            log('üéØ Select a method and start making unrestricted API calls', 'warning');
            
            // Initialize default method
            initializeMethod();
        });
    </script>
</body>
</html>