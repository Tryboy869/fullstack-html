<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VALIDATEUR CORS - Test des M√©thodes de Contournement</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { scroll-behavior: smooth; }
        .terminal { background: #0f172a; font-family: 'SF Mono', 'Courier New', monospace; font-size: 14px; line-height: 1.6; }
        .success { color: #22c55e; } .error { color: #ef4444; } .info { color: #3b82f6; } .warning { color: #f59e0b; } .grey { color: #9ca3af; }
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .test-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem; }
    </style>
</head>

<body class="bg-slate-900 text-slate-200 min-h-screen">
    <div id="app" class="container mx-auto p-4 md:p-6">
        
        <header class="bg-slate-800/50 backdrop-blur rounded-lg p-6 mb-6 border border-slate-700">
            <h1 class="text-3xl font-bold mb-2 text-sky-400">üî• Validateur de M√©thodes CORS</h1>
            <p class="text-slate-400">Tester et valider les techniques de contournement CORS c√¥t√© client dans un fichier HTML unique.</p>
        </header>

        <div class="bg-slate-800 rounded-lg p-6 mb-6 border border-slate-700">
            <h2 class="text-xl font-bold mb-4 text-emerald-400">üß™ Tests Automatiques</h2>
            <p class="text-slate-400 mb-4">Cliquez pour tester automatiquement chaque m√©thode contre des endpoints connus et voir ce qui fonctionne r√©ellement.</p>
            <div class="flex flex-col sm:flex-row gap-4">
                <button onclick="runAutomatedTests()" class="w-full sm:w-auto bg-emerald-600 hover:bg-emerald-700 px-6 py-3 rounded-lg font-bold transition-transform transform hover:scale-105">
                    üöÄ Lancer les Tests Automatiques
                </button>
                <button onclick="copyLogs()" class="w-full sm:w-auto bg-slate-600 hover:bg-slate-700 px-6 py-3 rounded-lg font-bold transition-transform">
                    üìã Copier les Logs
                </button>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <div class="bg-slate-800 rounded-lg p-6 border border-slate-700">
                <h3 class="text-lg font-bold mb-4 text-sky-400">üì° Test Manuel</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm mb-2 text-slate-400">M√©thode de contournement :</label>
                        <select id="bypass-method" class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2">
                            <option value="worker-proxy">‚úÖ Web Worker Proxy (La plus viable)</option>
                            <option value="jsonp">‚ö†Ô∏è JSONP (Conditionnel / Legacy)</option>
                            <option value="websocket">‚ùå WebSocket Bridge (Non applicable)</option>
                            <option value="postmessage">‚ùå PostMessage Tunnel (Non fonctionnel)</option>
                            <option value="data-uri">‚ùå Data URI Injection (Non fonctionnel)</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm mb-2 text-slate-400">URL Cible :</label>
                        <input type="url" id="target-url" class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2" value="https://jsonplaceholder.typicode.com/posts/1">
                    </div>
                    <div>
                        <label class="block text-sm mb-2 text-slate-400">M√©thode HTTP :</label>
                        <select id="http-method" class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2">
                            <option value="GET">GET</option><option value="POST">POST</option><option value="PUT">PUT</option><option value="DELETE">DELETE</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm mb-2 text-slate-400">Headers (JSON) :</label>
                        <textarea id="headers-input" class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 h-20 text-sm font-mono" placeholder='{ "Content-Type": "application/json" }'></textarea>
                    </div>
                    <div>
                        <label class="block text-sm mb-2 text-slate-400">Body (JSON) :</label>
                        <textarea id="body-input" class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 h-20 text-sm font-mono" placeholder='{ "title": "test", "body": "...", "userId": 1 }'></textarea>
                    </div>
                    <button onclick="executeManualRequest()" class="w-full bg-blue-600 hover:bg-blue-700 px-4 py-3 rounded-lg font-bold transition-transform transform hover:scale-105">
                        üåê Ex√©cuter la Requ√™te Manuelle
                    </button>
                </div>
            </div>
            <div class="bg-slate-800 rounded-lg p-6 border border-slate-700">
                <h3 class="text-lg font-bold mb-4 text-amber-400">üìä Terminal de Logs</h3>
                <div id="response-output" class="terminal p-4 rounded-lg h-[450px] overflow-y-auto bg-slate-900"></div>
            </div>
        </div>
    </div>

<script>
// ===================================================================================
// üî• SYST√àME DE VALIDATION CORS - IMPLEMENTATION CORRIG√âE
// ===================================================================================

const logOutput = document.getElementById('response-output');

// --- SYST√àME DE LOGGING AM√âLIOR√â ---
function log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const colorClass = { info: 'text-sky-400', success: 'text-emerald-400', error: 'text-red-500', warning: 'text-amber-400', grey: 'text-slate-500' }[type];
    logOutput.innerHTML += `<div class="${colorClass}"><span class="text-slate-600">[${timestamp}]</span> ${message.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</div>`;
    logOutput.scrollTop = logOutput.scrollHeight;
}

function clearLogs() {
    logOutput.innerHTML = '';
}

function copyLogs() {
    navigator.clipboard.writeText(logOutput.innerText).then(() => {
        log('‚úÖ Logs copi√©s dans le presse-papiers !', 'success');
    }, () => {
        log('‚ùå Erreur lors de la copie des logs.', 'error');
    });
}

// ===================================================================================
// üöÄ M√âTHODE 1: WEB WORKER PROXY (La plus viable)
// EXPLICATION : Le `fetch` depuis un Worker n'est pas li√© √† l'origine de la page principale de la m√™me mani√®re.
// Il peut effectuer des requ√™tes "simples" (GET, HEAD, POST sans headers complexes) sans preflight CORS.
// Il sera cependant BLOQU√â pour les requ√™tes "complexes" qui n√©cessitent un preflight (ex: PUT, DELETE, ou POST avec Content-Type: application/json).
// ===================================================================================
class WebWorkerProxy {
    constructor() {
        const workerCode = `
            self.onmessage = async (e) => {
                const { id, url, options } = e.data;
                try {
                    const response = await fetch(url, options);
                    const responseData = await response.text();
                    self.postMessage({ id, success: true, status: response.status, statusText: response.statusText, data: responseData });
                } catch (error) {
                    self.postMessage({ id, success: false, error: error.message });
                }
            };
        `;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        this.worker = new Worker(URL.createObjectURL(blob));
    }

    request(url, options) {
        return new Promise((resolve, reject) => {
            const id = Math.random().toString(36);
            const timeout = setTimeout(() => reject(new Error('Timeout de la requ√™te Worker')), 10000);

            const messageHandler = (e) => {
                if (e.data.id === id) {
                    clearTimeout(timeout);
                    this.worker.removeEventListener('message', messageHandler);
                    if (e.data.success) {
                        resolve(e.data);
                    } else {
                        reject(new Error(e.data.error));
                    }
                }
            };
            this.worker.addEventListener('message', messageHandler);
            this.worker.postMessage({ id, url, options });
        });
    }
}

// ===================================================================================
// ‚ö†Ô∏è M√âTHODE 2: JSONP (Legacy / Conditionnel)
// EXPLICATION : Ne fonctionne QUE si le serveur distant est sp√©cifiquement configur√© pour r√©pondre avec
// un script JavaScript qui appelle une fonction (callback). Les API REST modernes ne supportent PAS JSONP.
// Cette m√©thode √©chouera donc sur 99% des API actuelles.
// ===================================================================================
class JSONPBypass {
    request(url, options) {
        return Promise.reject(new Error("JSONP n'est pas adapt√© aux API REST modernes. Le serveur doit supporter un param√®tre 'callback'."));
    }
}

// ===================================================================================
// ‚ùå M√âTHODES NON FONCTIONNELLES POUR LE CONTOURNEMENT CORS
// EXPLICATION : Ces m√©thodes sont bas√©es sur des incompr√©hensions communes.
// - WebSocket : Protocole diff√©rent (ws://), ne peut pas faire de requ√™tes HTTP.
// - PostMessage/Data URI (iframe) : Un iframe avec une origine "opaque" (data:) a des permissions
//   encore PLUS STRICTES que la page principale et ne peut pas contourner CORS.
// ===================================================================================
class NonFunctionalMethod {
    constructor(name) { this.name = name; }
    request(url, options) { return Promise.reject(new Error(`La m√©thode ${this.name} est conceptuellement incorrecte pour contourner CORS pour des appels API REST.`)); }
}

// --- GESTIONNAIRE CENTRAL DES M√âTHODES ---
const methods = {
    'worker-proxy': { instance: new WebWorkerProxy(), name: 'Web Worker Proxy' },
    'jsonp': { instance: new JSONPBypass(), name: 'JSONP' },
    'websocket': { instance: new NonFunctionalMethod('WebSocket'), name: 'WebSocket Bridge' },
    'postmessage': { instance: new NonFunctionalMethod('PostMessage'), name: 'PostMessage Tunnel' },
    'data-uri': { instance: new NonFunctionalMethod('Data URI'), name: 'Data URI Injection' },
};

// ===================================================================================
// --- LOGIQUE DE L'INTERFACE UTILISATEUR ET DES TESTS ---
// ===================================================================================

async function executeRequest(methodKey, url, httpOptions) {
    const { instance, name } = methods[methodKey];
    log(`‚ñ∂Ô∏è Test en cours: [${name}] | ${httpOptions.method} ${url}`, 'info');

    try {
        const response = await instance.request(url, httpOptions);
        log(`‚úÖ SUCC√àS: [${name}] | Status: ${response.status} ${response.statusText}`, 'success');
        try {
            const jsonData = JSON.parse(response.data);
            log(`<pre class="text-slate-400 text-xs">${JSON.stringify(jsonData, null, 2)}</pre>`, 'grey');
        } catch {
            log(response.data.substring(0, 200) + '...', 'grey');
        }
        return true;
    } catch (error) {
        log(`‚ùå √âCHEC: [${name}] | ${error.message}`, 'error');
        return false;
    }
}

async function executeManualRequest() {
    clearLogs();
    const methodKey = document.getElementById('bypass-method').value;
    const url = document.getElementById('target-url').value;
    const httpMethod = document.getElementById('http-method').value;
    const headersText = document.getElementById('headers-input').value;
    const bodyText = document.getElementById('body-input').value;

    if (!url) {
        log('Veuillez entrer une URL cible.', 'error');
        return;
    }

    let headers = {};
    let body = undefined;
    try {
        if (headersText.trim()) headers = JSON.parse(headersText);
        if (bodyText.trim() && ['POST', 'PUT'].includes(httpMethod)) body = bodyText;
    } catch (e) {
        log('JSON invalide dans les Headers ou le Body.', 'error');
        return;
    }
    
    await executeRequest(methodKey, url, { method: httpMethod, headers, body });
}

// --- SYST√àME DE TESTS AUTOMATIQUES ---
async function runAutomatedTests() {
    clearLogs();
    log('üöÄ D√©marrage des tests automatiques...', 'warning');

    const testScenarios = [
        {
            description: "Requ√™te GET simple (sans preflight)",
            url: "https://jsonplaceholder.typicode.com/posts/1",
            options: { method: 'GET' },
            expected: { 'worker-proxy': 'success' }
        },
        {
            description: "Requ√™te POST complexe (d√©clenche un preflight CORS)",
            url: "https://jsonplaceholder.typicode.com/posts",
            options: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title: 'CORS Test' })
            },
            expected: { 'worker-proxy': 'failure' }
        }
    ];

    for (const scenario of testScenarios) {
        log(`\n------------------------------------------------\nüî¨ Sc√©nario: ${scenario.description}\n------------------------------------------------`, 'warning');
        for (const methodKey in methods) {
            await executeRequest(methodKey, scenario.url, scenario.options);
        }
    }
    log('\nüèÅ Tests automatiques termin√©s.', 'warning');
    log('‚û°Ô∏è CONCLUSION : Seul le Web Worker peut r√©ussir les requ√™tes SIMPLES. Aucune m√©thode 100% client ne peut universellement contourner les requ√™tes COMPLEXES √† cause des preflights (OPTIONS) impos√©s par les navigateurs.', 'info');
}

document.addEventListener('DOMContentLoaded', () => {
    clearLogs();
    log('üî• Validateur de M√©thodes CORS Initialis√©.', 'success');
    log('üí° Pr√™t √† lancer les tests automatiques ou manuels.', 'info');
});

</script>
</body>
</html>