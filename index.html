<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D√©monstration API REST Client-Side</title>

    <style>
        :root {
            --bg-color: #1a1d21; --surface-color: #2c313a; --primary-color: #4a90e2;
            --text-color: #f0f0f0; --subtext-color: #a0a0a0; --success-color: #7ed321;
            --error-color: #d0021b; --font-family: 'Segoe UI', system-ui, sans-serif;
        }
        body {
            font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 2rem; font-size: 16px; line-height: 1.6;
        }
        .container { max-width: 1200px; margin: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; }
        .card { background-color: var(--surface-color); border-radius: 8px; padding: 1.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        h1, h2, h3 { color: var(--text-color); border-bottom: 2px solid var(--primary-color); padding-bottom: 0.5rem; margin-top: 0; }
        h1 { grid-column: 1 / -1; text-align: center; }
        button {
            background-color: var(--primary-color); color: white; border: none; padding: 0.75rem 1rem;
            border-radius: 5px; cursor: pointer; font-size: 1em; transition: background-color 0.2s;
            display: inline-block; margin: 0.25rem 0; width: 100%;
        }
        button:hover { background-color: #5a9ee8; }
        button.delete { background-color: var(--error-color); }
        button.delete:hover { background-color: #e0223b; }
        input {
            width: calc(100% - 20px); background: var(--bg-color); border: 1px solid #444; color: var(--text-color);
            padding: 10px; border-radius: 5px; margin-bottom: 1rem;
        }
        .response-area {
            background-color: #111; border-radius: 5px; padding: 1rem; white-space: pre-wrap;
            word-wrap: break-word; font-family: 'Courier New', Courier, monospace; min-height: 200px;
        }
        .response-area.success { border-left: 5px solid var(--success-color); }
        .response-area.error { border-left: 5px solid var(--error-color); color: var(--error-color); }
        .user-list table { width: 100%; border-collapse: collapse; }
        .user-list th, .user-list td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #444; }
        .user-list th { color: var(--primary-color); }
        .auth-status { text-align: center; padding: 1rem; background: var(--surface-color); grid-column: 1 / -1; border-radius: 8px; }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>üöÄ API REST Client-Side : D√©monstration</h1>
        
        <div id="auth-status-card" class="auth-status">Statut: Non Authentifi√©</div>

        <div class="card">
            <h2>Endpoints API</h2>
            <div id="login-form">
                <h3>POST /api/auth/login</h3>
                <input type="text" id="username" placeholder="Username (admin)" value="admin">
                <input type="password" id="password" placeholder="Password (password)" value="password">
                <button id="login-btn">Login</button>
            </div>
            <hr>
            <h3>Utilisateurs</h3>
            <button id="get-users-btn">GET /api/users</button>
            <button id="get-user-1-btn">GET /api/users/1</button>
            <button id="delete-user-1-btn" class="delete">DELETE /api/users/1</button>
            <hr>
            <div id="create-user-form">
                <h3>POST /api/users</h3>
                <input type="text" id="create-name" placeholder="Nom">
                <input type="email" id="create-email" placeholder="Email">
                <button id="create-user-btn">Cr√©er Utilisateur</button>
            </div>
            <hr>
            <div id="update-user-form">
                <h3>PUT /api/users/2</h3>
                <input type="text" id="update-name" placeholder="Nouveau nom">
                <input type="email" id="update-email" placeholder="Nouvel email">
                <button id="update-user-btn">Modifier Utilisateur 2</button>
            </div>
        </div>

        <div class="card">
            <h2>R√©ponse de l'API</h2>
            <pre id="response-area" class="response-area">La r√©ponse de l'API appara√Ætra ici...</pre>
        </div>

        <div class="card user-list" style="grid-column: 1 / -1;">
            <h2>Donn√©es en direct (IndexedDB)</h2>
            <table id="users-table">
                <thead>
                    <tr><th>ID</th><th>Nom</th><th>Email</th></tr>
                </thead>
                <tbody>
                    <tr><td colspan="3">Chargement des donn√©es...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

<script>
class ClientSideAPI {
    /**
     * Initialise la base de donn√©es et les routes de l'API.
     */
    constructor() {
        this.db = null;
        this.jwtSecret = 'secret-key-for-demo-only';
    }

    /**
     * Ouvre la connexion IndexedDB et pr√©-remplit les donn√©es si n√©cessaire.
     */
    async initDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('ClientSideDB', 1);

            request.onupgradeneeded = event => {
                const db = event.target.result;
                const userStore = db.createObjectStore('users', { keyPath: 'id', autoIncrement: true });
                userStore.createIndex('email', 'email', { unique: true });

                // Donn√©es de test
                const demoUsers = [
                    { name: 'Alice', email: 'alice@example.com' },
                    { name: 'Bob', email: 'bob@example.com' },
                    { name: 'Charlie', email: 'charlie@example.com' },
                ];
                demoUsers.forEach(user => userStore.add(user));
            };

            request.onsuccess = event => {
                this.db = event.target.result;
                console.log('Database initialized successfully.');
                resolve();
            };
            request.onerror = event => {
                console.error('Database error:', event.target.errorCode);
                reject(event.target.error);
            };
        });
    }

    /**
     * Point d'entr√©e principal pour toutes les requ√™tes API.
     * G√®re l'authentification puis route la requ√™te.
     */
    async handleRequest(method, path, data = null, headers = {}) {
        try {
            // V√©rification de l'authentification pour les routes prot√©g√©es
            if (!path.startsWith('/api/auth') && path !== '/api/users' && method === 'GET') {
                const token = headers.Authorization?.split(' ')[1];
                if (!this.checkAuth(token)) {
                    return this.formatResponse({ error: 'Unauthorized' }, 401);
                }
            }
             if (method !== 'GET' && !path.startsWith('/api/auth')) {
                const token = headers.Authorization?.split(' ')[1];
                if (!this.checkAuth(token)) {
                    return this.formatResponse({ error: 'Unauthorized' }, 401);
                }
            }


            return await this.handleRoute(method, path, data);
        } catch (error) {
            console.error("Internal Server Error:", error);
            return this.formatResponse({ error: 'Internal Server Error', detail: error.message }, 500);
        }
    }

    // ===============================================
    // == 1. ROUTER: handleRoute(method, path, data)
    // ===============================================
    async handleRoute(method, path, data) {
        const pathParts = path.split('/').filter(p => p);
        const resource = pathParts[1];
        const id = pathParts[2] ? parseInt(pathParts[2]) : null;

        if (resource === 'users') {
            if (method === 'GET' && !id) return await this.getUsers();
            if (method === 'GET' && id) return await this.getUserById(id);
            if (method === 'POST') return await this.createUser(data);
            if (method === 'PUT' && id) return await this.updateUser(id, data);
            if (method === 'DELETE' && id) return await this.deleteUser(id);
        }
        
        if (resource === 'auth' && pathParts[2] === 'login' && method === 'POST') {
             return this.login(data);
        }

        return this.formatResponse({ error: 'Not Found' }, 404);
    }

    // ========================================================
    // == 2. LOGIQUE M√âTIER: processData(operation, input)
    // ========================================================
    processData(operation, input) {
        switch (operation) {
            case 'CREATE_USER':
                if (!input.name || !input.email) {
                    throw new Error('Name and email are required.');
                }
                if (!/\S+@\S+\.\S+/.test(input.email)) {
                    throw new Error('Invalid email format.');
                }
                return { name: input.name, email: input.email }; // Donn√©es nettoy√©es
            
            case 'UPDATE_USER':
                 if (!input.name && !input.email) {
                    throw new Error('Name or email must be provided for update.');
                }
                 if (input.email && !/\S+@\S+\.\S+/.test(input.email)) {
                    throw new Error('Invalid email format.');
                }
                return input;
        }
    }

    // ===================================================
    // == 3. PERSISTENCE: saveToStorage(key, data)
    // ===================================================
    async saveToStorage(operation, storeName, payload) {
        return new Promise((resolve, reject) => {
            if (!this.db) reject(new Error("Database not initialized."));
            
            const transaction = this.db.transaction(storeName, 'readwrite');
            const store = transaction.objectStore(storeName);
            let request;

            switch (operation) {
                case 'ADD': request = store.add(payload.data); break;
                case 'PUT': request = store.put(payload.data); break;
                case 'DELETE': request = store.delete(payload.key); break;
                default: reject(new Error('Invalid storage operation.')); return;
            }
            
            transaction.oncomplete = () => resolve(request.result || { success: true });
            transaction.onerror = (event) => reject(event.target.error);
        });
    }

    async readFromStorage(operation, storeName, key = null) {
        return new Promise((resolve, reject) => {
            if (!this.db) reject(new Error("Database not initialized."));
            
            const transaction = this.db.transaction(storeName, 'readonly');
            const store = transaction.objectStore(storeName);
            const request = operation === 'GET_ALL' ? store.getAll() : store.get(key);

            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }

    // ===================================================
    // == 4. R√âPONSE: formatResponse(data, status)
    // ===================================================
    formatResponse(data, status = 200) {
        return { status, body: data };
    }

    // ==============================================
    // == 5. AUTHENTIFICATION: checkAuth(token)
    // ==============================================
    checkAuth(token) {
        if (!token) return false;
        try {
            const decoded = JSON.parse(atob(token.split('.')[1]));
            // Dans une vraie app, on v√©rifierait la signature et l'expiration
            return decoded.user === 'admin';
        } catch (e) {
            return false;
        }
    }
    
    // --- Impl√©mentation des Endpoints ---
    
    login(credentials) {
        if (credentials.username === 'admin' && credentials.password === 'password') {
            const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
            const payload = btoa(JSON.stringify({ user: 'admin', iat: Date.now() }));
            const signature = btoa(this.jwtSecret); // Signature simul√©e
            const token = `${header}.${payload}.${signature}`;
            return this.formatResponse({ token }, 200);
        }
        return this.formatResponse({ error: 'Invalid credentials' }, 401);
    }
    
    async getUsers() {
        const users = await this.readFromStorage('GET_ALL', 'users');
        return this.formatResponse(users, 200);
    }
    
    async getUserById(id) {
        const user = await this.readFromStorage('GET_ONE', 'users', id);
        return user ? this.formatResponse(user, 200) : this.formatResponse({ error: 'User not found' }, 404);
    }
    
    async createUser(data) {
        try {
            const processedData = this.processData('CREATE_USER', data);
            const newId = await this.saveToStorage('ADD', 'users', { data: processedData });
            const newUser = await this.readFromStorage('GET_ONE', 'users', newId);
            return this.formatResponse(newUser, 201);
        } catch(error) {
            return this.formatResponse({ error: 'Bad Request', detail: error.message }, 400);
        }
    }

    async updateUser(id, data) {
        try {
            const existingUser = await this.readFromStorage('GET_ONE', 'users', id);
            if (!existingUser) return this.formatResponse({ error: 'User not found' }, 404);

            const processedData = this.processData('UPDATE_USER', data);
            const updatedUserData = { ...existingUser, ...processedData };
            
            await this.saveToStorage('PUT', 'users', { data: updatedUserData });
            return this.formatResponse(updatedUserData, 200);
        } catch(error) {
            return this.formatResponse({ error: 'Bad Request', detail: error.message }, 400);
        }
    }
    
    async deleteUser(id) {
        const existingUser = await this.readFromStorage('GET_ONE', 'users', id);
        if (!existingUser) return this.formatResponse({ error: 'User not found' }, 404);
        
        await this.saveToStorage('DELETE', 'users', { key: id });
        return this.formatResponse({ message: 'User deleted successfully' }, 200);
    }
}


// --- Classe pour g√©rer l'interface utilisateur et les interactions ---
class App {
    constructor(api) {
        this.api = api;
        this.elements = {
            loginBtn: document.getElementById('login-btn'),
            getUsersBtn: document.getElementById('get-users-btn'),
            getUser1Btn: document.getElementById('get-user-1-btn'),
            deleteUser1Btn: document.getElementById('delete-user-1-btn'),
            createUserBtn: document.getElementById('create-user-btn'),
            updateUserBtn: document.getElementById('update-user-btn'),
            responseArea: document.getElementById('response-area'),
            usersTableBody: document.querySelector('#users-table tbody'),
            authStatus: document.getElementById('auth-status-card'),
        };
        this.jwt = localStorage.getItem('jwt_token');
    }

    async init() {
        await this.api.initDatabase();
        this.attachEventListeners();
        this.updateAuthStatus();
        this.refreshUsersList();
    }

    attachEventListeners() {
        this.elements.loginBtn.onclick = () => this.handleLogin();
        this.elements.getUsersBtn.onclick = () => this.handleApiCall('GET', '/api/users');
        this.elements.getUser1Btn.onclick = () => this.handleApiCall('GET', '/api/users/1');
        this.elements.deleteUser1Btn.onclick = () => this.handleApiCall('DELETE', '/api/users/1');
        this.elements.createUserBtn.onclick = () => {
            const data = {
                name: document.getElementById('create-name').value,
                email: document.getElementById('create-email').value,
            };
            this.handleApiCall('POST', '/api/users', data);
        };
        this.elements.updateUserBtn.onclick = () => {
             const data = {
                name: document.getElementById('update-name').value,
                email: document.getElementById('update-email').value,
            };
            this.handleApiCall('PUT', '/api/users/2', data);
        };
    }
    
    async handleLogin() {
        const data = {
            username: document.getElementById('username').value,
            password: document.getElementById('password').value,
        };
        const response = await this.api.handleRequest('POST', '/api/auth/login', data);
        this.logResponse(response);
        if (response.status === 200) {
            this.jwt = response.body.token;
            localStorage.setItem('jwt_token', this.jwt);
            this.updateAuthStatus();
        }
    }

    async handleApiCall(method, path, data = null) {
        const headers = { Authorization: `Bearer ${this.jwt}` };
        const response = await this.api.handleRequest(method, path, data, headers);
        this.logResponse(response);
        
        // Rafra√Æchir la liste si des donn√©es ont √©t√© modifi√©es
        if (method !== 'GET' && response.status < 400) {
            this.refreshUsersList();
        }
    }
    
    updateAuthStatus() {
        if(this.api.checkAuth(this.jwt)) {
            this.elements.authStatus.textContent = "Statut: Authentifi√© (Token JWT pr√©sent)";
            this.elements.authStatus.style.background = 'var(--success-color)';
        } else {
            this.elements.authStatus.textContent = "Statut: Non Authentifi√©";
            this.elements.authStatus.style.background = 'var(--error-color)';
        }
    }

    async refreshUsersList() {
        const response = await this.api.getUsers();
        const users = response.body;
        this.elements.usersTableBody.innerHTML = '';
        if (users && users.length > 0) {
            users.forEach(user => {
                const row = `<tr><td>${user.id}</td><td>${user.name}</td><td>${user.email}</td></tr>`;
                this.elements.usersTableBody.innerHTML += row;
            });
        } else {
            this.elements.usersTableBody.innerHTML = '<tr><td colspan="3">Aucun utilisateur trouv√©.</td></tr>';
        }
    }

    logResponse(response) {
        this.elements.responseArea.textContent = JSON.stringify(response, null, 2);
        if (response.status >= 400) {
            this.elements.responseArea.className = 'response-area error';
        } else {
            this.elements.responseArea.className = 'response-area success';
        }
    }
}


// Point d'entr√©e de l'application
document.addEventListener('DOMContentLoaded', () => {
    const api = new ClientSideAPI();
    const app = new App(api);
    app.init();
});
</script>

</body>
</html>